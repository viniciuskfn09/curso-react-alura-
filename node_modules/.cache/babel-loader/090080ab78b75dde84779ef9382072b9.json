{"ast":null,"code":"'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n  // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n  // `Function#prototype` is non-writable and non-configurable so can never be modified.\n  if (property === 'length' || property === 'prototype') {\n    return;\n  } // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\n\n  if (property === 'arguments' || property === 'caller') {\n    return;\n  }\n\n  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n    return;\n  }\n\n  Object.defineProperty(to, property, fromDescriptor);\n}; // `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\n\n\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);\n};\n\nconst changePrototype = (to, from) => {\n  const fromPrototype = Object.getPrototypeOf(from);\n\n  if (fromPrototype === Object.getPrototypeOf(to)) {\n    return;\n  }\n\n  Object.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name'); // We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\n\nconst changeToString = (to, from, name) => {\n  const withName = name === '' ? '' : `with ${name.trim()}() `;\n  const newToString = wrappedToString.bind(null, withName, from.toString()); // Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\n  Object.defineProperty(newToString, 'name', toStringName);\n  Object.defineProperty(to, 'toString', { ...toStringDescriptor,\n    value: newToString\n  });\n};\n\nconst mimicFn = (to, from, {\n  ignoreNonConfigurable = false\n} = {}) => {\n  const {\n    name\n  } = to;\n\n  for (const property of Reflect.ownKeys(from)) {\n    copyProperty(to, from, property, ignoreNonConfigurable);\n  }\n\n  changePrototype(to, from);\n  changeToString(to, from, name);\n  return to;\n};\n\nmodule.exports = mimicFn;","map":{"version":3,"sources":["C:/Users/Lenovo/Documents/REACT/curso-react-alura/node_modules/get-user-locale/node_modules/mimic-fn/index.js"],"names":["copyProperty","to","from","property","ignoreNonConfigurable","toDescriptor","Object","getOwnPropertyDescriptor","fromDescriptor","canCopyProperty","defineProperty","undefined","configurable","writable","enumerable","value","changePrototype","fromPrototype","getPrototypeOf","setPrototypeOf","wrappedToString","withName","fromBody","toStringDescriptor","Function","prototype","toStringName","toString","changeToString","name","trim","newToString","bind","mimicFn","Reflect","ownKeys","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nconst mimicFn = (to, from, {ignoreNonConfigurable = false} = {}) => {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n"]},"metadata":{},"sourceType":"script"}