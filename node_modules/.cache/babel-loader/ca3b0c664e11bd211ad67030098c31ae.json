{"ast":null,"code":"'use strict';\n\nconst mimicFn = require(\"mimic-fn\");\n\nconst mapAgeCleaner = require(\"map-age-cleaner\");\n\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\n\nconst mem = (fn, {\n  cacheKey,\n  cache = new Map(),\n  maxAge\n} = {}) => {\n  if (typeof maxAge === 'number') {\n    // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n    // @ts-expect-error\n    mapAgeCleaner(cache);\n  }\n\n  const memoized = function (...arguments_) {\n    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n    const cacheItem = cache.get(key);\n\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n\n    const result = fn.apply(this, arguments_);\n    cache.set(key, {\n      data: result,\n      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n    });\n    return result;\n  };\n\n  mimicFn(memoized, fn, {\n    ignoreNonConfigurable: true\n  });\n  cacheStore.set(memoized, cache);\n  return memoized;\n};\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport mem = require('mem');\n\nclass Example {\n    index = 0\n\n    @mem.decorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @mem.decorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\n\n\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\n  const input = target[propertyKey];\n\n  if (typeof input !== 'function') {\n    throw new TypeError('The decorated value must be a function');\n  }\n\n  delete descriptor.value;\n  delete descriptor.writable;\n\n  descriptor.get = function () {\n    if (!decoratorInstanceMap.has(this)) {\n      const value = mem(input, options);\n      decoratorInstanceMap.set(this, value);\n      return value;\n    }\n\n    return decoratorInstanceMap.get(this);\n  };\n};\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\n\n\nmem.clear = fn => {\n  const cache = cacheStore.get(fn);\n\n  if (!cache) {\n    throw new TypeError('Can\\'t clear a function that was not memoized!');\n  }\n\n  if (typeof cache.clear !== 'function') {\n    throw new TypeError('The cache Map can\\'t be cleared!');\n  }\n\n  cache.clear();\n};\n\nmodule.exports = mem;","map":{"version":3,"sources":["C:/Users/Lenovo/Documents/REACT/curso-react-alura/node_modules/get-user-locale/node_modules/mem/dist/index.js"],"names":["mimicFn","require","mapAgeCleaner","decoratorInstanceMap","WeakMap","cacheStore","mem","fn","cacheKey","cache","Map","maxAge","memoized","arguments_","key","cacheItem","get","data","result","apply","set","Date","now","Number","POSITIVE_INFINITY","ignoreNonConfigurable","decorator","options","target","propertyKey","descriptor","input","TypeError","value","writable","has","clear","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst mimicFn = require(\"mimic-fn\");\nconst mapAgeCleaner = require(\"map-age-cleaner\");\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nconst mem = (fn, { cacheKey, cache = new Map(), maxAge } = {}) => {\n    if (typeof maxAge === 'number') {\n        // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n        // @ts-expect-error\n        mapAgeCleaner(cache);\n    }\n    const memoized = function (...arguments_) {\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n        const cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem.data;\n        }\n        const result = fn.apply(this, arguments_);\n        cache.set(key, {\n            data: result,\n            maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n        });\n        return result;\n    };\n    mimicFn(memoized, fn, {\n        ignoreNonConfigurable: true\n    });\n    cacheStore.set(memoized, cache);\n    return memoized;\n};\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport mem = require('mem');\n\nclass Example {\n    index = 0\n\n    @mem.decorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @mem.decorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\n    const input = target[propertyKey];\n    if (typeof input !== 'function') {\n        throw new TypeError('The decorated value must be a function');\n    }\n    delete descriptor.value;\n    delete descriptor.writable;\n    descriptor.get = function () {\n        if (!decoratorInstanceMap.has(this)) {\n            const value = mem(input, options);\n            decoratorInstanceMap.set(this, value);\n            return value;\n        }\n        return decoratorInstanceMap.get(this);\n    };\n};\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\nmem.clear = (fn) => {\n    const cache = cacheStore.get(fn);\n    if (!cache) {\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\n    }\n    if (typeof cache.clear !== 'function') {\n        throw new TypeError('The cache Map can\\'t be cleared!');\n    }\n    cache.clear();\n};\nmodule.exports = mem;\n"]},"metadata":{},"sourceType":"script"}