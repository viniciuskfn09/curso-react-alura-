{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\n\nfunction mapAgeCleaner(map, property = 'maxAge') {\n  let processingKey;\n  let processingTimer;\n  let processingDeferred;\n\n  const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n    if (processingKey !== undefined) {\n      // If we are already processing an item, we can safely exit\n      return;\n    }\n\n    const setupTimer = item => __awaiter(this, void 0, void 0, function* () {\n      processingDeferred = p_defer_1.default();\n      const delay = item[1][property] - Date.now();\n\n      if (delay <= 0) {\n        // Remove the item immediately if the delay is equal to or below 0\n        map.delete(item[0]);\n        processingDeferred.resolve();\n        return;\n      } // Keep track of the current processed key\n\n\n      processingKey = item[0];\n      processingTimer = setTimeout(() => {\n        // Remove the item when the timeout fires\n        map.delete(item[0]);\n\n        if (processingDeferred) {\n          processingDeferred.resolve();\n        }\n      }, delay); // tslint:disable-next-line:strict-type-predicates\n\n      if (typeof processingTimer.unref === 'function') {\n        // Don't hold up the process from exiting\n        processingTimer.unref();\n      }\n\n      return processingDeferred.promise;\n    });\n\n    try {\n      for (const entry of map) {\n        yield setupTimer(entry);\n      }\n    } catch (_a) {// Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n    }\n\n    processingKey = undefined;\n  });\n\n  const reset = () => {\n    processingKey = undefined;\n\n    if (processingTimer !== undefined) {\n      clearTimeout(processingTimer);\n      processingTimer = undefined;\n    }\n\n    if (processingDeferred !== undefined) {\n      // tslint:disable-line:early-exit\n      processingDeferred.reject(undefined);\n      processingDeferred = undefined;\n    }\n  };\n\n  const originalSet = map.set.bind(map);\n\n  map.set = (key, value) => {\n    if (map.has(key)) {\n      // If the key already exist, remove it so we can add it back at the end of the map.\n      map.delete(key);\n    } // Call the original `map.set`\n\n\n    const result = originalSet(key, value); // If we are already processing a key and the key added is the current processed key, stop processing it\n\n    if (processingKey && processingKey === key) {\n      reset();\n    } // Always run the cleanup method in case it wasn't started yet\n\n\n    cleanup(); // tslint:disable-line:no-floating-promises\n\n    return result;\n  };\n\n  cleanup(); // tslint:disable-line:no-floating-promises\n\n  return map;\n}\n\nexports.default = mapAgeCleaner; // Add support for CJS\n\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;","map":{"version":3,"sources":["C:/Users/Lenovo/Documents/REACT/curso-react-alura/node_modules/map-age-cleaner/dist/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","p_defer_1","require","mapAgeCleaner","map","property","processingKey","processingTimer","processingDeferred","cleanup","undefined","setupTimer","item","default","delay","Date","now","delete","setTimeout","unref","promise","entry","_a","reset","clearTimeout","originalSet","set","bind","key","has","module"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\nfunction mapAgeCleaner(map, property = 'maxAge') {\n    let processingKey;\n    let processingTimer;\n    let processingDeferred;\n    const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n        if (processingKey !== undefined) {\n            // If we are already processing an item, we can safely exit\n            return;\n        }\n        const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {\n            processingDeferred = p_defer_1.default();\n            const delay = item[1][property] - Date.now();\n            if (delay <= 0) {\n                // Remove the item immediately if the delay is equal to or below 0\n                map.delete(item[0]);\n                processingDeferred.resolve();\n                return;\n            }\n            // Keep track of the current processed key\n            processingKey = item[0];\n            processingTimer = setTimeout(() => {\n                // Remove the item when the timeout fires\n                map.delete(item[0]);\n                if (processingDeferred) {\n                    processingDeferred.resolve();\n                }\n            }, delay);\n            // tslint:disable-next-line:strict-type-predicates\n            if (typeof processingTimer.unref === 'function') {\n                // Don't hold up the process from exiting\n                processingTimer.unref();\n            }\n            return processingDeferred.promise;\n        });\n        try {\n            for (const entry of map) {\n                yield setupTimer(entry);\n            }\n        }\n        catch (_a) {\n            // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n        }\n        processingKey = undefined;\n    });\n    const reset = () => {\n        processingKey = undefined;\n        if (processingTimer !== undefined) {\n            clearTimeout(processingTimer);\n            processingTimer = undefined;\n        }\n        if (processingDeferred !== undefined) { // tslint:disable-line:early-exit\n            processingDeferred.reject(undefined);\n            processingDeferred = undefined;\n        }\n    };\n    const originalSet = map.set.bind(map);\n    map.set = (key, value) => {\n        if (map.has(key)) {\n            // If the key already exist, remove it so we can add it back at the end of the map.\n            map.delete(key);\n        }\n        // Call the original `map.set`\n        const result = originalSet(key, value);\n        // If we are already processing a key and the key added is the current processed key, stop processing it\n        if (processingKey && processingKey === key) {\n            reset();\n        }\n        // Always run the cleanup method in case it wasn't started yet\n        cleanup(); // tslint:disable-line:no-floating-promises\n        return result;\n    };\n    cleanup(); // tslint:disable-line:no-floating-promises\n    return map;\n}\nexports.default = mapAgeCleaner;\n// Add support for CJS\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;\n"]},"metadata":{},"sourceType":"script"}